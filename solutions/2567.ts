/**
 * You are given an integer array nums.
 *
 *  The low score of nums is the minimum absolute difference between any two integers.
 *  The high score of nums is the maximum absolute difference between any two integers.
 *  The score of nums is the sum of the high and low scores.
 *
 * Return the minimum score after changing two elements of nums.
 * ---
 * That is - we want to minimize the sum of the largest and the smallest differences in the arrays.
 * Naively, best approach seems to be to start with bringing the biggest outliers in towards the center - that will
 * certainly reduce the high score.
 * Low score _might_ then increase (if we had, say, 1, 1, 7, 9, 11, 13 - bringing 1 and 13 into the center would
 * increase low score from 0 to 3), so perhaps be sure to bring them in to be the _same_ number.
 * Though of the high score is generated by numbers that have duplicates, high-score might still not change (i.e.
 * 1, 1, 13, 13 - no matter how you change one 1 and one 13, the high score will stay 12) - so maybe have to move two
 * numbers from one end of the (sorted) array? Indeed, from the examples, note that they're always changing the
 * two-lowest or two-highest, and always changing them so they are the same (which makes sense, as that ensures that the 
 * low score becomes (or, stays) 0).
 * 
 * Think we're onto something there:
 * - iterate through, keeping track of the three lowest and three highest (would use min/max-heaps for this if doing it academically)
 *   - (or, just sort and check, since we don't care about preserving the original)
 * - once complete, check whether `sorted[-1] - sorted[2]` or `sorted[-3] - sorted[0]` is smaller. That will be the
 *     new high score, and the new low score will be 0 (since we can change the outliers to be identical)
 * - (EDIT after some implementation - or, check also `sorted[-2]-sorted[1]`, for moving the two outliers inward)
 */
export function minimizeSum(nums: number[]): number {
    const length = nums.length;
    const sorted = nums.sort((a, b) => a - b)
    return Math.min(sorted[length-1]-sorted[2], sorted[length-2]-sorted[1], sorted[length-3]-sorted[0]);
}